'''
题目描述:
编程实现:
有一片海域划分为N*M个方格，其中有些海域已被污染(用0表示)，有些海域没被污染(用1表示)。请问这片
N*M海域中有几块是没被污染的独立海域（没被污染的独立海域是指该块海域上下左右被已污染的海域包围，且染N*M以外的海域都为已被污染的海域)
例如:N=4，M=5，4*5的海域中，已被污染海域和没被污染的海域如下图:
11000
10100
10000
11011
这块4*5的海域，有3块海域(绿色）没被污染，因为每一块的上下左右都被污染的海域包围。
输入描述:
第一行输入两个正整数N和M，N表示矩阵方格的行，M表示矩阵方格的列，N和M之间以一个英文逗号隔开
第二行开始输入N行，每行M个数字（数字只能为1或者0，1表示没被污染的海域，0表示已被污染的海域)
输出描述:输出一个整数，表示N*M的海域中有几块是没被污染的独立海域
'''
'''4,5
1,1,0,0,0
1,0,1,0,0
1,0,0,0,0
1,1,0,1,1
3'''
#输入
NMlst = input().split(',')
N = int(NMlst[0])#矩阵方格的行
M = int(NMlst[1])#矩阵方格的列
island = []#海域
for i in range(N):
    islandh = input().split(',')
    island.append(islandh)
#定义深度优先搜索算法函数
def dsf(x,y):
    #防止上下左右搜索超出边界或者遇到为零的区块
    if not 0<= x <N or not 0<= y <M or island[x][y] == '0':
        return None
    island[x][y] = '0'#已被搜索过，标记为零
    #上下左右搜索
    dsf(x - 1, y)
    dsf(x + 1, y)
    dsf(x , y - 1)
    dsf(x , y + 1)
#有多少块
cut = 0
for i in range(N):
    for j in range(M):
        if island[i][j] == '1':#当找到为一的块时开始深搜
            #将同一岛屿的全部标为0
            dsf(i,j)
            cut+=1
print(cut)
